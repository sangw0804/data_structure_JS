<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>heap.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BinarySearchTree.html">BinarySearchTree</a><ul class='methods'><li data-type='method'><a href="BinarySearchTree.html#_findMinimum">_findMinimum</a></li><li data-type='method'><a href="BinarySearchTree.html#find">find</a></li><li data-type='method'><a href="BinarySearchTree.html#size">size</a></li></ul></li><li><a href="Heap.html">Heap</a><ul class='methods'><li data-type='method'><a href="Heap.html#_compare">_compare</a></li><li data-type='method'><a href="Heap.html#insert">insert</a></li><li data-type='method'><a href="Heap.html#insertGen">insertGen</a></li><li data-type='method'><a href="Heap.html#pop">pop</a></li><li data-type='method'><a href="Heap.html#popGen">popGen</a></li><li data-type='method'><a href="Heap.html#size">size</a></li></ul></li><li><a href="PriorityQueue.html">PriorityQueue</a><ul class='methods'><li data-type='method'><a href="PriorityQueue.html#dequeue">dequeue</a></li><li data-type='method'><a href="PriorityQueue.html#dequeueGen">dequeueGen</a></li><li data-type='method'><a href="PriorityQueue.html#enqueue">enqueue</a></li><li data-type='method'><a href="PriorityQueue.html#enqueueGen">enqueueGen</a></li><li data-type='method'><a href="PriorityQueue.html#size">size</a></li></ul></li><li><a href="Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="Queue.html#dequeue">dequeue</a></li><li data-type='method'><a href="Queue.html#enqueue">enqueue</a></li><li data-type='method'><a href="Queue.html#size">size</a></li></ul></li><li><a href="SinglyLinkedList.html">SinglyLinkedList</a><ul class='methods'><li data-type='method'><a href="SinglyLinkedList.html#insert">insert</a></li><li data-type='method'><a href="SinglyLinkedList.html#insertGen">insertGen</a></li><li data-type='method'><a href="SinglyLinkedList.html#pop">pop</a></li><li data-type='method'><a href="SinglyLinkedList.html#popGen">popGen</a></li><li data-type='method'><a href="SinglyLinkedList.html#push">push</a></li><li data-type='method'><a href="SinglyLinkedList.html#pushGen">pushGen</a></li><li data-type='method'><a href="SinglyLinkedList.html#remove">remove</a></li><li data-type='method'><a href="SinglyLinkedList.html#removeGen">removeGen</a></li><li data-type='method'><a href="SinglyLinkedList.html#reverse">reverse</a></li><li data-type='method'><a href="SinglyLinkedList.html#shift">shift</a></li><li data-type='method'><a href="SinglyLinkedList.html#shiftGen">shiftGen</a></li><li data-type='method'><a href="SinglyLinkedList.html#size">size</a></li><li data-type='method'><a href="SinglyLinkedList.html#unshift">unshift</a></li><li data-type='method'><a href="SinglyLinkedList.html#unshiftGen">unshiftGen</a></li></ul></li><li><a href="Stack.html">Stack</a><ul class='methods'><li data-type='method'><a href="Stack.html#pop">pop</a></li><li data-type='method'><a href="Stack.html#push">push</a></li><li data-type='method'><a href="Stack.html#size">size</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">heap.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { INVALID_VALUE } from './error.js';
import { HeapNode } from './node.js';
import clone from '../node_modules/clone/clone.js';

/**
 * Heap 클래스.
 */
class Heap {
  /**
   * Heap 클래스의 생성자 함수.
   * @constructor
   * @param {boolean} max max 프로퍼티가 true 이면 maxHeap, false 이면 minHeap 이다.
   */
  constructor(max = true) {
    this.max = max;
    this.values = [];
    this.snapshots = [];
  }

  /**
   * maxHeap 과 minHeap 을 구분짓는 비교 함수.
   * @param {number} parentIndex
   * @param {number} childIndex
   * @returns {boolean} 부모와 자식 노드의 값의 대소 관계 비교 결과를 boolean으로 리턴.
   */
  _compare(parentIndex, childIndex) {
    // maxHeap 이면 부모 노드의 값이 자식 노드의 값보다 작은지 여부를 반환
    if (this.max) return this.values[parentIndex].value &lt; this.values[childIndex].value;
    // minHeap 이면 부모 노드의 값이 자식 노드의 값보다 큰지 여부를 반환
    return this.values[parentIndex].value > this.values[childIndex].value;
  }

  returnSnapshots() {
    const temp = this.snapshots;
    this.snapshots = [];
    return temp;
  }

  /**
   * 현재 heap의 노드 개수를 반환.
   * @returns {number}
   */
  size() {
    return this.values.length;
  }

  /**
   * 트리의 가장 아래에 value를 삽입한 뒤, 맞는 위치에 올때까지 위로 올린다.
   * @param {number} value
   * @param {*} isSnapshot
   * @throws {INVALID_VALUE} value가 number타입이 아닌 경우 예외 발생.
   * @returns {Heap} insert 완료된 자기 자신을 리턴한다.
   */
  insert(value, isSnapshot = false) {
    if (typeof value !== 'number') throw new Error(INVALID_VALUE);

    this.values.push(new HeapNode(value));
    if (isSnapshot) {
      this.snapshots.push(clone(this));
    }

    let index = this.size() - 1;
    let parentIndex = Math.floor((index - 1) / 2);
    if (isSnapshot &amp;&amp; index > 0) {
      this.values[index].colored = 'blue';
      this.values[parentIndex].colored = 'green';
      this.snapshots.push(clone(this));
    }

    while (index > 0 &amp;&amp; this._compare(parentIndex, index)) {
      [this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];
      if (isSnapshot) {
        this.snapshots.push(clone(this));
        delete this.values[index].colored;
        delete this.values[parentIndex].colored;
      }
      index = parentIndex;
      parentIndex = Math.floor((index - 1) / 2);
      if (isSnapshot &amp;&amp; index > 0) {
        this.values[index].colored = 'blue';
        this.values[parentIndex].colored = 'green';
        this.snapshots.push(clone(this));
      }
    }

    if (isSnapshot &amp;&amp; index > 0) {
      delete this.values[index].colored;
      delete this.values[parentIndex].colored;
    }

    return this;
  }

  /**
   * 트리의 root 에 있는 값을 리턴하고 가장 마지막에 있는 값을 root로 옮긴 다음, 맞는 위치에 올때까지 밑으로 내린다.
   * @param {*} isSnapshot
   * @returns {*} root에 있는 노드의 value.
   */
  pop(isSnapshot = false) {
    if (!this.size()) return undefined;
    if (this.size() === 1) return this.values.pop();

    const poppedValue = this.values[0];
    if (isSnapshot) {
      poppedValue.colored = 'white';
      this.snapshots.push(clone(this));
      this.values[this.values.length - 1].colored = 'blue';
      this.snapshots.push(clone(this));
    }

    this.values[0] = this.values.pop();

    if (isSnapshot) {
      this.snapshots.push(clone(this));
    }

    let index = 0;
    let childIndex = index * 2 + 1;

    while (childIndex &lt; this.size()) {
      if (isSnapshot) {
        this.values[index].colored = 'blue';
        this.values[childIndex].colored = 'green';
        this.snapshots.push(clone(this));
      }

      if (childIndex + 1 &lt; this.size() &amp;&amp; this._compare(childIndex, childIndex + 1)) {
        if (isSnapshot) {
          delete this.values[childIndex].colored;
          this.values[childIndex + 1].colored = 'green';
          this.snapshots.push(clone(this));
        }
        childIndex += 1;
      }
      if (!this._compare(index, childIndex)) {
        if (isSnapshot) {
          delete this.values[index].colored;
          delete this.values[childIndex].colored;
        }
        break;
      }
      [this.values[index], this.values[childIndex]] = [this.values[childIndex], this.values[index]];

      if (isSnapshot) {
        this.snapshots.push(clone(this));
        delete this.values[index].colored;
        delete this.values[childIndex].colored;
      }
      index = childIndex;
      childIndex = index * 2 + 1;
    }

    if (isSnapshot) {
      delete this.values[0].colored;
    }

    return poppedValue;
  }

  /**
   * insert 메소드의 진행 상태를 generate 하는 제너레이터 함수.
   * @generator
   * @param {number} value
   * @throws {INVALID_VALUE} value가 number타입이 아닌 경우 예외 발생.
   * @yields {Heap} 진행 상태가 시각적으로 표시된 자기 자신.
   * @returns {Heap} insert 완료된 자기 자신을 리턴한다.
   */
  *insertGen(value) {
    if (typeof value !== 'number') throw new Error(INVALID_VALUE);

    this.values.push(new HeapNode(value));

    yield this;

    let index = this.size() - 1;
    let parentIndex = Math.floor((index - 1) / 2);
    if (index > 0) {
      this.values[index].colored = 'blue';
      this.values[parentIndex].colored = 'green';
      yield this;
    }

    while (index > 0 &amp;&amp; this._compare(parentIndex, index)) {
      [this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];

      yield this;
      delete this.values[index].colored;
      delete this.values[parentIndex].colored;

      index = parentIndex;
      parentIndex = Math.floor((index - 1) / 2);
      if (index > 0) {
        this.values[index].colored = 'blue';
        this.values[parentIndex].colored = 'green';
        yield this;
      }
    }

    if (index > 0) {
      delete this.values[index].colored;
      delete this.values[parentIndex].colored;
    }

    return this;
  }

  /**
   * pop 메소드의 진행 상태를 generate 하는 제너레이터 함수.
   * @generator
   * @yields {Heap} 진행 상태가 시각적으로 표시된 자기 자신.
   * @returns {*} root에 있는 노드의 value.
   */
  *popGen() {
    if (!this.size()) return undefined;
    if (this.size() === 1) return this.values.pop();

    const poppedValue = this.values[0];

    poppedValue.colored = 'white';
    yield this;
    this.values[this.values.length - 1].colored = 'blue';
    yield this;

    this.values[0] = this.values.pop();

    yield this;

    let index = 0;
    let childIndex = index * 2 + 1;

    while (childIndex &lt; this.size()) {
      this.values[index].colored = 'blue';
      this.values[childIndex].colored = 'green';
      yield this;

      if (childIndex + 1 &lt; this.size() &amp;&amp; this._compare(childIndex, childIndex + 1)) {
        delete this.values[childIndex].colored;
        this.values[childIndex + 1].colored = 'green';
        yield this;

        childIndex += 1;
      }
      if (!this._compare(index, childIndex)) {
        delete this.values[index].colored;
        delete this.values[childIndex].colored;

        break;
      }
      [this.values[index], this.values[childIndex]] = [this.values[childIndex], this.values[index]];

      yield this;
      delete this.values[index].colored;
      delete this.values[childIndex].colored;

      index = childIndex;
      childIndex = index * 2 + 1;
    }

    delete this.values[0].colored;

    return poppedValue;
  }
}

export { Heap };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Feb 21 2019 21:52:43 GMT+0900 (KST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
